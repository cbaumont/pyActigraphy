{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "toc": true
   },
   "source": [
    "<h1>Table of Contents<span class=\"tocSkip\"></span></h1>\n",
    "<div class=\"toc\"><ul class=\"toc-item\"><li><span><a href=\"#Cleaning-files-individually\" data-toc-modified-id=\"Cleaning-files-individually-1\"><span class=\"toc-item-num\">1&nbsp;&nbsp;</span>Cleaning files individually</a></span></li><li><span><a href=\"#Cleaning-files-by-batch\" data-toc-modified-id=\"Cleaning-files-by-batch-2\"><span class=\"toc-item-num\">2&nbsp;&nbsp;</span>Cleaning files by batch</a></span><ul class=\"toc-item\"><li><span><a href=\"#Start/stop-time-log-file\" data-toc-modified-id=\"Start/stop-time-log-file-2.1\"><span class=\"toc-item-num\">2.1&nbsp;&nbsp;</span>Start/stop-time log file</a></span></li><li><span><a href=\"#Reading-SST-log-files-with-the-Reader-class\" data-toc-modified-id=\"Reading-SST-log-files-with-the-Reader-class-2.2\"><span class=\"toc-item-num\">2.2&nbsp;&nbsp;</span>Reading SST log files with the Reader class</a></span></li></ul></li><li><span><a href=\"#Test-with-real-data\" data-toc-modified-id=\"Test-with-real-data-3\"><span class=\"toc-item-num\">3&nbsp;&nbsp;</span>Test with real data</a></span></li></ul></div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# How to discard invalid sequences in actigraphy recordings before analysis"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Quite frequently, actigraphy recordings contain sequences that do not correspond to the participant's activities but rather to artefacts, such as bringing the actimeter to the participant's home or removing the actimeter from the participant to read the acquired data.\n",
    "Such meaningless data happen either at the beginning, when the record starts before the actimeter is actually worn by the participant or at the end, when the actimeter is removed by the participants before the end of the data acquisition. Or even at both ends...\n",
    "\n",
    "\n",
    "In any case, it is necessary, before any analysis of the data, to discard these invalid sequences of activity counts and *pyActigraphy* provides the adequate tools for that."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pyActigraphy\n",
    "import os"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import plotly.graph_objs as go"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# retrieve path to example files\n",
    "fpath = os.path.join(os.path.dirname(pyActigraphy.__file__),'tests/data/')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Read test file\n",
    "raw = pyActigraphy.io.read_raw_awd(fpath+'example_01.AWD')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Check the start time of the actigraphy recording\n",
    "raw.start_time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Check the duration of the recording\n",
    "raw.duration()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "go.Figure(data=[go.Scatter(x=raw.data.index, y=raw.data)], layout=go.Layout())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The initial recording starts the 23rd of January, around 13:00 and lasts for 12 days, 18 hours and 41 minutes. Both at the beginning and at the end of the recording, the recorded activity does not seem to be valid:\n",
    "- at the beginning, this mixture of zero and non-zero activity counts with no cyclic pattern is most likely due to the fact the acquisition started before the participant actually wore the actimeter but the actimeter was nontheless manipulated for demonstration purposes\n",
    "- towards the end of the recording, the activity counts suddenly fall to zero, when the participant removed the actimeter, until the last epochs, when the actimeter was most likely manipulated for reading the acquired data.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Cleaning files individually"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "With *pyActigraphy*, it is quite easy to mask these invalid sequences by specifiying a start and stop times for the analysis of the recordings."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In our example above, to discard the first hour of data acquisition and keep only 9 days of recordings:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_cropped = pyActigraphy.io.read_raw_awd(\n",
    "    fpath+'example_01.AWD', \n",
    "    start_time='1918-01-24 08:00:00',\n",
    "    period='9 days')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_cropped.start_time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_cropped.duration()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "go.Figure(data=[go.Scatter(x=raw_cropped.data.index, y=raw_cropped.data)], layout=go.Layout())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let us now verify the impact of discarding invalid activity counts on the usual rest-activity rhythm variables:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "raw.IS()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_cropped.IS()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The difference is quite substantial, isn't it?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Cleaning files by batch"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It is certainly managable to invalidate activity sequences in a few files by specifying a start and a stop time. However, it is less so when one wants to apply this procedure to hundreds or thousands of recordings. Fortunately, *pyActigraphy* allows users to specify a start and a stop time to actigraphy recordings by batch.\n",
    "\n",
    "\n",
    "All it needs is a start/stop-time (SST) log file.\n",
    "\n",
    "\n",
    "\n",
    "A Start/stop-time log file consists in a list of participant's ID associated with two datetimes corresponding to the requested start and end of the actigraphy recording, respectively. These datetimes will overwrite the actual start and stop times of the recordings.\n",
    "\n",
    "-------------\n",
    "\n",
    "Start/stop-time log file *must* be formatted as the following:\n",
    "\n",
    "|Subject_id|Start_time|Stop_time|Remarks|\n",
    "|----------|----------|---------|-------|\n",
    "|name_in_header | YYYY-MM-DD HH:MM| YYYY-MM-DD HH:MM| WhateverTextYouWant|"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Start/stop-time log file"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As an example, let us first create an SSTLog object in order to inspect it:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from pyActigraphy.log import SSTLog"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sstlog_ods = pyActigraphy.log.read_sst_log(fpath+'example_sstlog.ods')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sstlog_csv = pyActigraphy.log.read_sst_log(fpath+'example_sstlog.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sstlog_xls = pyActigraphy.log.read_sst_log(fpath+'example_sstlog.xlsx')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To access to the data contained in the log file:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "sstlog_ods.log"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sstlog_csv.log"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sstlog_xls.log"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Please, notice that the duration of the time interval between the start and stop times is automatically calculated and therefore does not need to be entered in the log file."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A `summary` function is available. It returns the min/max/median/mean of the durations found in the log file:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sstlog_ods.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sstlog_csv.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sstlog_xls.summary()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Reading SST log files with the Reader class"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As it is possible to read actigraphy files by batch with the `Reader` class, this class has been extended to read a SST log file.\n",
    "\n",
    "As an illustration, let us first read a small batch of files:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rawReader = pyActigraphy.io.read_raw(input_path=fpath+'example_0[0-3]*.AWD', reader_type='AWD')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Check how many files were found and read:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "len(rawReader.readers)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To read a SST log files containing the start and stop times for these recordings:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rawReader.read_sst_log(fpath+'example_sstlog.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, verify the data found in this log file by accessing and displaying the log associated to the reader object:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "rawReader.sst_log.log"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then, let us check the IS values of these recordings:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rawReader.IS()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are quite low. Indeed, the SST log has been read by the reader object but the start and stop times have not been applied to the actigraphy recordings yet.\n",
    "\n",
    "To do so:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rawReader.apply_sst(verbose=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "By using the `verbose` option, one can easily check if there is an entry in the SST log file for each actigraphy recording."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, the IS values display a significant change for the recordings found in the SST log file:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rawReader.IS()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The actigraphy recordings have been truncated according to the start and stop times specified in the SST log file."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Et voilà! Easy, isn't it?"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Raw Cell Format",
  "kernelspec": {
   "display_name": "pyActi37",
   "language": "python",
   "name": "pyacti37"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.12"
  },
  "latex_envs": {
   "LaTeX_envs_menu_present": true,
   "autoclose": false,
   "autocomplete": true,
   "bibliofile": "biblio.bib",
   "cite_by": "apalike",
   "current_citInitial": 1,
   "eqLabelWithNumbers": true,
   "eqNumInitial": 1,
   "hotkeys": {
    "equation": "Ctrl-E",
    "itemize": "Ctrl-I"
   },
   "labels_anchors": false,
   "latex_user_defs": false,
   "report_style_numbering": false,
   "user_envs_cfg": false
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": true,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": true,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
